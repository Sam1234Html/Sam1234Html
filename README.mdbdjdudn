// app.js (or server.js) - Combined MERN Application (Conceptual for "One File" Constraint)

// --- PART 1: Node.js/Express.js Backend with MongoDB ---

// Server Dependencies
require('dotenv').config(); // Load environment variables
const express = require('express');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const cors = require('cors'); // For allowing cross-origin requests from React frontend

const app = express();

// --- Configuration ---
const PORT = process.env.PORT || 5000;
const MONGO_URI = process.env.MONGO_URI;
const JWT_SECRET = process.env.JWT_SECRET;

// --- Connect to MongoDB ---
mongoose.connect(MONGO_URI)
    .then(() => console.log('MongoDB Connected Successfully'))
    .catch(err => {
        console.error('MongoDB Connection Error:', err);
        process.exit(1); // Exit process if connection fails
    });

// --- Mongoose Schemas and Models ---

// User Schema
const UserSchema = new mongoose.Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    createdAt: { type: Date, default: Date.now }
});

// Hash password before saving
UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) {
        return next();
    }
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

// Compare password method
UserSchema.methods.matchPassword = async function(enteredPassword) {
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

// Comment Schema
const CommentSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    username: { type: String, required: true }, // Store username directly for display
    text: { type: String, required: true },
    createdAt: { type: Date, default: Date.now }
});

// Post Schema
const PostSchema = new mongoose.Schema({
    title: { type: String, required: true, trim: true },
    content: { type: String, required: true },
    author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    authorName: { type: String, required: true }, // Store author name directly for display
    imageUrl: { type: String, default: '' }, // Optional: for image uploads
    comments: [CommentSchema], // Embed comments
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
});

const Post = mongoose.model('Post', PostSchema);

// --- Middleware ---
app.use(express.json()); // Body parser for JSON requests
app.use(cors()); // Enable CORS for all routes

// --- JWT Authentication Middleware ---
const protect = (req, res, next) => {
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(' ')[1];
            const decoded = jwt.verify(token, JWT_SECRET);
            req.user = decoded.id; // Store user ID from token in request
            next();
        } catch (error) {
            res.status(401).json({ message: 'Not authorized, token failed' });
        }
    }
    if (!token) {
        res.status(401).json({ message: 'Not authorized, no token' });
    }
};

// --- Backend API Routes (Controllers & Routes Combined) ---

// Auth Routes
app.post('/api/auth/register', async (req, res) => {
    const { username, email, password } = req.body;
    try {
        const userExists = await User.findOne({ email });
        if (userExists) {
            return res.status(400).json({ message: 'User already exists' });
        }
        const user = await User.create({ username, email, password });
        res.status(201).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            token: jwt.sign({ id: user._id, username: user.username }, JWT_SECRET, { expiresIn: '1h' })
        });
    } catch (error) {
        res.status(500).json({ message: 'Server error during registration', error: error.message });
    }
});

app.post('/api/auth/login', async (req, res) => {
    const { email, password } = req.body;
    try {
        const user = await User.findOne({ email });
        if (user && (await user.matchPassword(password))) {
            res.json({
                _id: user._id,
                username: user.username,
                email: user.email,
                token: jwt.sign({ id: user._id, username: user.username }, JWT_SECRET, { expiresIn: '1h' })
            });
        } else {
            res.status(401).json({ message: 'Invalid email or password' });
        }
    } catch (error) {
        res.status(500).json({ message: 'Server error during login', error: error.message });
    }
});

// Blog Post Routes
// Get all posts
app.get('/api/posts', protect, async (req, res) => {
    try {
        const posts = await Post.find().populate('author', 'username').sort({ createdAt: -1 });
        res.json(posts);
    } catch (error) {
        res.status(500).json({ message: 'Server error fetching posts', error: error.message });
    }
});

// Get single post
app.get('/api/posts/:id', protect, async (req, res) => {
    try {
        const post = await Post.findById(req.params.id).populate('author', 'username');
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        res.json(post);
    } catch (error) {
        res.status(500).json({ message: 'Server error fetching post', error: error.message });
    }
});

// Create a new post
app.post('/api/posts', protect, async (req, res) => {
    const { title, content, imageUrl } = req.body;
    try {
        // Fetch user to get username for post model
        const user = await User.findById(req.user);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }
        const post = await Post.create({
            title,
            content,
            author: req.user,
            authorName: user.username, // Store username for easier display
            imageUrl
        });
        res.status(201).json(post);
    } catch (error) {
        res.status(500).json({ message: 'Server error creating post', error: error.message });
    }
});

// Update a post
app.put('/api/posts/:id', protect, async (req, res) => {
    const { title, content, imageUrl } = req.body;
    try {
        let post = await Post.findById(req.params.id);
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        // Check if user is the author
        if (post.author.toString() !== req.user) {
            return res.status(403).json({ message: 'Not authorized to update this post' });
        }
        post.title = title || post.title;
        post.content = content || post.content;
        post.imageUrl = imageUrl || post.imageUrl;
        post.updatedAt = Date.now();
        await post.save();
        res.json(post);
    } catch (error) {
        res.status(500).json({ message: 'Server error updating post', error: error.message });
    }
});

// Delete a post
app.delete('/api/posts/:id', protect, async (req, res) => {
    try {
        const post = await Post.findById(req.params.id);
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        // Check if user is the author
        if (post.author.toString() !== req.user) {
            return res.status(403).json({ message: 'Not authorized to delete this post' });
        }
        await Post.deleteOne({ _id: req.params.id }); // Use deleteOne or findByIdAndDelete
        res.json({ message: 'Post removed' });
    } catch (error) {
        res.status(500).json({ message: 'Server error deleting post', error: error.message });
    }
});

// Comment Routes
// Add a comment to a post
app.post('/api/posts/:id/comments', protect, async (req, res) => {
    const { text } = req.body;
    try {
        const post = await Post.findById(req.params.id);
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        const user = await User.findById(req.user);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }
        const newComment = {
            user: req.user,
            username: user.username,
            text,
            createdAt: new Date()
        };
        post.comments.push(newComment);
        await post.save();
        // Return the newly added comment (last one in the array)
        res.status(201).json(post.comments[post.comments.length - 1]);
    } catch (error) {
        res.status(500).json({ message: 'Server error adding comment', error: error.message });
    }
});

// --- General Error Handling Middleware ---
app.use((err, req, res, next) => {
    console.error(err.stack); // Log error stack for debugging
    res.status(err.statusCode || 500).json({
        message: err.message || 'Something went wrong on the server!'
    });
});

// --- Start the Server ---
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`MongoDB URI: ${MONGO_URI ? 'Connected' : 'Not Set - Please check .env'}`);
});


// =====================================================================================================
// --- PART 2: React.js Frontend (Conceptual Code - This part CANNOT be directly run by Node.js) ---
//
// This code block is provided to conceptually complete the "one file" assignment.
// In a real MERN stack, this would live in your `client/src/App.jsx` and related files,
// and would be built and served separately (e.g., via `npm run dev` in the client directory).
//
// To make this runnable, you would typically:
// 1. Create a React project (e.g., `npx create-react-app client` or `npm create vite@latest client -- --template react`).
// 2. Install `axios` in the client directory (`npm install axios`).
// 3. Replace the content of `client/src/App.jsx` (and potentially other files) with the relevant parts below.
// 4. Modify API calls to target `http://localhost:5000/api` or your server's deployed URL.
// =====================================================================================================

/*
// --- Conceptual `client/src/App.jsx` content ---
// (Requires 'axios' for API requests: `npm install axios`)

import React, { useState, useEffect, createContext, useContext } from 'react';
import axios from 'axios';

// --- Context for Authentication ---
const AuthContext = createContext(null);

const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(JSON.parse(localStorage.getItem('userInfo')) || null);
    const [token, setToken] = useState(localStorage.getItem('token') || null);

    const login = (userData, userToken) => {
        setUser(userData);
        setToken(userToken);
        localStorage.setItem('userInfo', JSON.stringify(userData));
        localStorage.setItem('token', userToken);
    };

    const logout = () => {
        setUser(null);
        setToken(null);
        localStorage.removeItem('userInfo');
        localStorage.removeItem('token');
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout }}>
            {children}
        </AuthContext.Provider>
    );
};

// --- API Service (conceptual `client/src/services/api.js`) ---
const API_URL = 'http://localhost:5000/api'; // Ensure this matches your Node.js server port

const getAuthHeaders = () => {
    const token = localStorage.getItem('token');
    return {
        headers: {
            Authorization: `Bearer ${token}`
        }
    };
};

const api = {
    register: (userData) => axios.post(`${API_URL}/auth/register`, userData),
    login: (credentials) => axios.post(`${API_URL}/auth/login`, credentials),
    getPosts: () => axios.get(`${API_URL}/posts`, getAuthHeaders()),
    getPostById: (id) => axios.get(`${API_URL}/posts/${id}`, getAuthHeaders()),
    createPost: (postData) => axios.post(`${API_URL}/posts`, postData, getAuthHeaders()),
    updatePost: (id, postData) => axios.put(`${API_URL}/posts/${id}`, postData, getAuthHeaders()),
    deletePost: (id) => axios.delete(`${API_URL}/posts/${id}`, getAuthHeaders()),
    addComment: (postId, commentData) => axios.post(`${API_URL}/posts/${postId}/comments`, commentData, getAuthHeaders())
};

// --- Reusable Components (conceptual `client/src/components/`) ---

// AuthForm Component (for Login and Register)
const AuthForm = ({ type, onAuthSuccess }) => {
    const [username, setUsername] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const { login: authLogin } = useContext(AuthContext);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        try {
            let res;
            if (type === 'register') {
                res = await api.register({ username, email, password });
            } else { // 'login'
                res = await api.login({ email, password });
            }
            authLogin({ id: res.data._id, username: res.data.username, email: res.data.email }, res.data.token);
            onAuthSuccess();
        } catch (err) {
            setError(err.response?.data?.message || 'Authentication failed');
        }
    };

    return (
        <div className="max-w-md mx-auto mt-10 p-6 bg-white rounded-lg shadow-md">
            <h2 className="text-2xl font-bold mb-4 text-center">{type === 'register' ? 'Register' : 'Login'}</h2>
            <form onSubmit={handleSubmit}>
                {type === 'register' && (
                    <div className="mb-4">
                        <label className="block text-gray-700 text-sm font-bold mb-2">Username:</label>
                        <input
                            type="text"
                            className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                            value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            required={type === 'register'}
                        />
                    </div>
                )}
                <div className="mb-4">
                    <label className="block text-gray-700 text-sm font-bold mb-2">Email:</label>
                    <input
                        type="email"
                        className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>
                <div className="mb-6">
                    <label className="block text-gray-700 text-sm font-bold mb-2">Password:</label>
                    <input
                        type="password"
                        className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                </div>
                {error && <p className="text-red-500 text-xs italic mb-4">{error}</p>}
                <div className="flex items-center justify-between">
                    <button
                        type="submit"
                        className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                    >
                        {type === 'register' ? 'Register' : 'Login'}
                    </button>
                </div>
            </form>
        </div>
    );
};

// PostList Component
const PostList = ({ onSelectPost, onEditPost, onDeletePost }) => {
    const [posts, setPosts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const { token } = useContext(AuthContext);

    useEffect(() => {
        const fetchPosts = async () => {
            if (!token) return; // Don't fetch if not authenticated
            try {
                const res = await api.getPosts();
                setPosts(res.data);
            } catch (err) {
                setError(err.response?.data?.message || 'Failed to fetch posts');
            } finally {
                setLoading(false);
            }
        };
        fetchPosts();
    }, [token]);

    if (loading) return <div className="text-center mt-8">Loading posts...</div>;
    if (error) return <div className="text-center mt-8 text-red-500">{error}</div>;

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
            {posts.length === 0 && <p className="col-span-full text-center text-gray-500">No posts available. Create one!</p>}
            {posts.map(post => (
                <div key={post._id} className="bg-white p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 className="text-xl font-bold mb-2 text-blue-700 cursor-pointer hover:underline"
                            onClick={() => onSelectPost(post._id)}>
                            {post.title}
                        </h3>
                        <p className="text-gray-600 text-sm mb-3 line-clamp-3">{post.content}</p>
                        {post.imageUrl && <img src={post.imageUrl} alt={post.title} className="w-full h-32 object-cover mb-3 rounded" />}
                        <p className="text-xs text-gray-500">
                            By {post.authorName} on {new Date(post.createdAt).toLocaleDateString()}
                        </p>
                    </div>
                    <div className="mt-4 flex space-x-2">
                        <button
                            onClick={() => onEditPost(post)}
                            className="bg-yellow-500 hover:bg-yellow-600 text-white text-sm py-1 px-3 rounded"
                        >
                            Edit
                        </button>
                        <button
                            onClick={() => onDeletePost(post._id)}
                            className="bg-red-500 hover:bg-red-600 text-white text-sm py-1 px-3 rounded"
                        >
                            Delete
                        </button>
                    </div>
                </div>
            ))}
        </div>
    );
};

// PostDetail Component
const PostDetail = ({ postId, onBackToList }) => {
    const [post, setPost] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [commentText, setCommentText] = useState('');
    const [commentError, setCommentError] = useState('');
    const { token, user } = useContext(AuthContext);

    useEffect(() => {
        const fetchPost = async () => {
            if (!token || !postId) return;
            try {
                const res = await api.getPostById(postId);
                setPost(res.data);
            } catch (err) {
                setError(err.response?.data?.message || 'Failed to fetch post details');
            } finally {
                setLoading(false);
            }
        };
        fetchPost();
    }, [postId, token]);

    const handleAddComment = async (e) => {
        e.preventDefault();
        setCommentError('');
        if (!commentText.trim()) {
            setCommentError('Comment cannot be empty.');
            return;
        }
        try {
            con
