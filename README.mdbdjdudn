// server.js

require('dotenv').config(); // Load environment variables from .env file
const express = require('express');
const app = express();
const { v4: uuidv4 } = require('uuid'); // For generating unique IDs for products

// --- Environment Variables ---
const PORT = process.env.PORT || 3000;
const API_SECRET_KEY = process.env.API_SECRET_KEY || 'supersecretkey123'; // Default for testing

// --- In-Memory Product Data (Simulating a Database) ---
let products = [
    {
        id: "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        name: "Wireless Headphones",
        description: "High-fidelity sound, noise-cancelling, 20-hour battery life.",
        price: 199.99,
        category: "Electronics",
        stock: 50,
        createdAt: new Date("2024-01-15T10:00:00Z"),
        updatedAt: new Date("2024-01-15T10:00:00Z")
    },
    {
        id: "b2c3d4e5-f6a7-8901-2345-67890abcdef1",
        name: "Ergonomic Office Chair",
        description: "Adjustable lumbar support, breathable mesh, 360-degree swivel.",
        price: 349.99,
        category: "Furniture",
        stock: 20,
        createdAt: new Date("2024-02-20T11:30:00Z"),
        updatedAt: new Date("2024-02-20T11:30:00Z")
    },
    {
        id: "c3d4e5f6-a7b8-9012-3456-7890abcdef23",
        name: "Smart Coffee Maker",
        description: "Brew coffee from your phone, programmable, 12-cup capacity.",
        price: 129.99,
        category: "Home Appliances",
        stock: 35,
        createdAt: new Date("2024-03-01T09:15:00Z"),
        updatedAt: new Date("2024-03-01T09:15:00Z")
    },
    {
        id: "d4e5f6a7-b8c9-0123-4567-890abcdef345",
        name: "Portable Bluetooth Speaker",
        description: "Waterproof, rich bass, 10-hour playtime.",
        price: 79.99,
        category: "Electronics",
        stock: 75,
        createdAt: new Date("2024-03-10T14:45:00Z"),
        updatedAt: new Date("2024-03-10T14:45:00Z")
    },
    {
        id: "e5f6a7b8-c9d0-1234-5678-90abcdef4567",
        name: "Yoga Mat",
        description: "Eco-friendly, non-slip surface, extra thick for comfort.",
        price: 29.99,
        category: "Fitness",
        stock: 100,
        createdAt: new Date("2024-04-05T08:00:00Z"),
        updatedAt: new Date("2024-04-05T08:00:00Z")
    },
    {
        id: "f6a7b8c9-d0e1-2345-6789-0abcdef56789",
        name: "Electric Kettle",
        description: "Fast boiling, stainless steel, automatic shut-off.",
        price: 39.99,
        category: "Home Appliances",
        stock: 60,
        createdAt: new Date("2024-04-12T16:20:00Z"),
        updatedAt: new Date("2024-04-12T16:20:00Z")
    }
];


// --- Middleware ---

// 1. JSON Body Parser
// Parses incoming JSON request bodies.
app.use(express.json());

// 2. Custom Logging Middleware
// Logs details of every incoming request.
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);
    next(); // Pass control to the next middleware/route handler
});

// 3. Authentication Middleware
// Checks for a valid API_SECRET_KEY in the 'x-api-key' header for protected routes.
// For simplicity, applies to all routes for demonstration. In a real app, apply only to protected ones.
const authenticateAPIKey = (req, res, next) => {
    const apiKey = req.headers['x-api-key'];
    if (!apiKey || apiKey !== API_SECRET_KEY) {
        return res.status(401).json({ message: 'Unauthorized: Invalid or missing API key.' });
    }
    next();
};
app.use(authenticateAPIKey); // Apply authentication to all routes starting here

// 4. Product Validation Middleware (for POST and PUT requests)
const validateProduct = (req, res, next) => {
    const { name, description, price, category, stock } = req.body;

    if (!name || typeof name !== 'string' || name.trim() === '') {
        return res.status(400).json({ message: 'Product name is required and must be a non-empty string.' });
    }
    if (!description || typeof description !== 'string' || description.trim() === '') {
        return res.status(400).json({ message: 'Product description is required and must be a non-empty string.' });
    }
    if (typeof price !== 'number' || price <= 0) {
        return res.status(400).json({ message: 'Product price is required and must be a positive number.' });
    }
    if (!category || typeof category !== 'string' || category.trim() === '') {
        return res.status(400).json({ message: 'Product category is required and must be a non-empty string.' });
    }
    if (typeof stock !== 'number' || stock < 0 || !Number.isInteger(stock)) {
        return res.status(400).json({ message: 'Product stock is required and must be a non-negative integer.' });
    }
    next();
};

// --- RESTful API Routes ---

const API_PREFIX = '/api/products';

// GET /api/products: Get all products (with filtering, pagination, search)
app.get(API_PREFIX, (req, res) => {
    let filteredProducts = [...products]; // Create a copy to manipulate

    // 1. Search functionality
    const searchTerm = req.query.search;
    if (searchTerm) {
        const lowerCaseSearchTerm = searchTerm.toLowerCase();
        filteredProducts = filteredProducts.filter(p =>
            p.name.toLowerCase().includes(lowerCaseSearchTerm) ||
            p.description.toLowerCase().includes(lowerCaseSearchTerm)
        );
    }

    // 2. Filtering by category
    const categoryFilter = req.query.category;
    if (categoryFilter) {
        filteredProducts = filteredProducts.filter(p =>
            p.category.toLowerCase() === categoryFilter.toLowerCase()
        );
    }

    // 3. Filtering by price range
    const minPrice = parseFloat(req.query.minPrice);
    const maxPrice = parseFloat(req.query.maxPrice);
    if (!isNaN(minPrice)) {
        filteredProducts = filteredProducts.filter(p => p.price >= minPrice);
    }
    if (!isNaN(maxPrice)) {
        filteredProducts = filteredProducts.filter(p => p.price <= maxPrice);
    }

    // 4. Sorting
    const sortBy = req.query.sortBy; // e.g., 'name', 'price', 'createdAt'
    const order = req.query.order === 'desc' ? -1 : 1; // 1 for ascending, -1 for descending

    if (sortBy) {
        filteredProducts.sort((a, b) => {
            if (a[sortBy] < b[sortBy]) return -1 * order;
            if (a[sortBy] > b[sortBy]) return 1 * order;
            return 0;
        });
    }

    // 5. Pagination
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const startIndex = (page - 1) * limit;
    const endIndex = page * limit;

    const paginatedProducts = filteredProducts.slice(startIndex, endIndex);

    res.status(200).json({
        totalProducts: filteredProducts.length,
        currentPage: page,
        limit: limit,
        products: paginatedProducts
    });
});

// GET /api/products/:id: Get a specific product
app.get(`${API_PREFIX}/:id`, (req, res) => {
    const { id } = req.params;
    const product = products.find(p => p.id === id);

    if (!product) {
        // If product not found, pass to the 404 error handler
        return res.status(404).json({ message: `Product with ID ${id} not found.` });
    }
    res.status(200).json(product);
});

// POST /api/products: Create a new product
app.post(API_PREFIX, validateProduct, (req, res) => {
    const newProduct = {
        id: uuidv4(), // Generate a unique ID
        ...req.body,
        createdAt: new Date(),
        updatedAt: new Date()
    };
    products.push(newProduct);
    res.status(201).json(newProduct); // 201 Created status
});

// PUT /api/products/:id: Update a product
app.put(`${API_PREFIX}/:id`, validateProduct, (req, res) => {
    const { id } = req.params;
    const productIndex = products.findIndex(p => p.id === id);

    if (productIndex === -1) {
        return res.status(404).json({ message: `Product with ID ${id} not found.` });
    }

    // Update product properties, retain original id and createdAt
    products[productIndex] = {
        ...products[productIndex], // Keep existing properties
        ...req.body,               // Apply updates from request body
        id: products[productIndex].id, // Ensure ID remains the same
        createdAt: products[productIndex].createdAt, // Ensure createdAt remains the same
        updatedAt: new Date()      // Update updatedAt timestamp
    };

    res.status(200).json(products[productIndex]);
});

// DELETE /api/products/:id: Delete a product
app.delete(`${API_PREFIX}/:id`, (req, res) => {
    const { id } = req.params;
    const initialLength = products.length;
    products = products.filter(p => p.id !== id);

    if (products.length === initialLength) {
        return res.status(404).json({ message: `Product with ID ${id} not found.` });
    }
    res.status(204).send(); // 204 No Content for successful deletion
});


// --- Error Handling Middleware ---

// 1. 404 Not Found Middleware
// This middleware will be called if no route handles the request.
app.use((req, res, next) => {
    res.status(404).json({ message: `Route ${req.originalUrl} not found.` });
});

// 2. Generic Error Handling Middleware
// This handles any errors passed from previous middleware or route handlers.
app.use((err, req, res, next) => {
    console.error(err.stack); // Log the error stack for debugging
    res.status(500).json({ message: 'Internal Server Error', error: err.message });
});


// --- Start the Server ---
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
    console.log(`Access API at http://localhost:${PORT}/api/products`);
    console.log(`API Secret Key for authentication: ${API_SECRET_KEY}`);
});

