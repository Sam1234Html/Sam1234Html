-- Question 1: Achieving 1NF (First Normal Form) ðŸ› ï¸
-- Task: Transform the ProductDetail table (OrderID, CustomerName, Products)
-- where Products contains multiple values, into 1NF.
-- This requires splitting the 'Products' column into multiple rows.
-- Note: The exact syntax for splitting strings into rows varies by SQL dialect.
-- This example uses a common technique often simulated with a recursive CTE or a numbers table.
-- For simplicity, let's assume a hypothetical function like UNNEST_STRING_ARRAY or a series of UNION ALL for known products.

-- Method 1: Using a Recursive CTE (Common Table Expression) - SQL dialects like PostgreSQL, SQL Server, Oracle often support this.
-- This is a more dynamic way to split comma-separated strings.
-- For MySQL, this often requires a numbers table or stored procedures, or more complex string functions.

-- Let's define a CTE to simulate the ProductDetail table for demonstration.
WITH ProductDetail AS (
    SELECT 101 AS OrderID, 'John Doe' AS CustomerName, 'Laptop, Mouse' AS Products UNION ALL
    SELECT 102, 'Jane Smith', 'Tablet, Keyboard, Mouse' UNION ALL
    SELECT 103, 'Emily Clark', 'Phone'
),
-- This CTE splits the 'Products' string into individual product names.
-- Note: MySQL 8.0+ can use Common Table Expressions, but string splitting is still manual.
-- For a truly portable MySQL solution, you'd likely use a numbers table or procedural code.
-- This example conceptualizes the logic assuming string splitting capability.
ProductSplit AS (
    SELECT
        OrderID,
        CustomerName,
        TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX(Products, ',', n.digit+1), ',', -1)) AS Product
    FROM
        ProductDetail
    JOIN (
        SELECT 0 AS digit UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 -- Extend as needed for max products
    ) AS n
    ON CHAR_LENGTH(Products) - CHAR_LENGTH(REPLACE(Products, ',', '')) >= n.digit
)
SELECT
    OrderID,
    CustomerName,
    Product
FROM
    ProductSplit
ORDER BY
    OrderID, Product;

-- Explanation for Q1:
-- The original table violates 1NF because the 'Products' column is multi-valued (contains repeating groups of products).
-- To achieve 1NF, we break down each multi-valued entry into separate rows, so each row
-- contains an atomic value for 'Product'. This query creates a result set that is in 1NF.
-- In a real-world scenario, you'd typically create a new 'OrderProducts' table:
-- CREATE TABLE OrderProducts (
--     OrderID INT,
--     Product VARCHAR(255),
--     PRIMARY KEY (OrderID, Product)
-- );
-- Then INSERT data into it after splitting.

-- Question 2: Achieving 2NF (Second Normal Form) ðŸ§©
-- Task: Transform the OrderDetails table into 2NF by removing partial dependencies.
-- The table has OrderID (PK), CustomerName, Product, Quantity.
-- Partial dependency: CustomerName depends only on OrderID (part of a potential composite PK if Product is included),
-- not on (OrderID, Product).
-- To achieve 2NF, we decompose the table into two new tables:
-- 1. Orders (OrderID, CustomerName)
-- 2. OrderItems (OrderID, Product, Quantity)

-- Assume the OrderDetails table exists as described:
-- CREATE TABLE OrderDetails (
--     OrderID INT,
--     CustomerName VARCHAR(255),
--     Product VARCHAR(255),
--     Quantity INT,
--     PRIMARY KEY (OrderID, Product) -- Assuming (OrderID, Product) is the composite primary key
-- );
-- INSERT INTO OrderDetails (OrderID, CustomerName, Product, Quantity) VALUES
-- (101, 'John Doe', 'Laptop', 2),
-- (101, 'John Doe', 'Mouse', 1),
-- (102, 'Jane Smith', 'Tablet', 3),
-- (102, 'Jane Smith', 'Keyboard', 1),
-- (102, 'Jane Smith', 'Mouse', 2),
-- (103, 'Emily Clark', 'Phone', 1);

-- Query to create the 'Orders' table (containing OrderID and CustomerName)
-- This table removes the partial dependency of CustomerName on OrderID.
-- We use DISTINCT to get unique OrderID-CustomerName pairs.
SELECT DISTINCT
    OrderID,
    CustomerName
FROM
    OrderDetails
ORDER BY
    OrderID;

-- Query to create the 'OrderItems' table (containing OrderID, Product, Quantity)
-- This table retains the details of each item in an order.
SELECT
    OrderID,
    Product,
    Quantity
FROM
    OrderDetails
ORDER BY
    OrderID, Product;

-- Explanation for Q2:
-- The original 'OrderDetails' table with a composite primary key like (OrderID, Product)
-- violates 2NF because 'CustomerName' depends only on 'OrderID' (a part of the primary key),
-- not on the full composite key (OrderID, Product). This is a partial dependency.
-- To resolve this, we decompose the table:
-- 1. A new 'Orders' table is created (or selected) with 'OrderID' as the primary key and 'CustomerName' as a non-key attribute.
--    'CustomerName' is now fully dependent on 'OrderID' in this new table.
-- 2. A new 'OrderItems' table is created (or selected) with a composite primary key (OrderID, Product),
--    and 'Quantity' fully depends on this composite key.
-- This two-table structure ensures that each non-key attribute is fully dependent on its respective primary key.
